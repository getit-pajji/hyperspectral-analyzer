<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Krishi Kendra Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Core Analysis Libraries -->
    <script>!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).matFileParser=t()}(this,(function(){"use strict";const e={1:"int8",2:"uint8",3:"int16",4:"uint16",5:"int32",6:"uint32",7:"single",9:"int64",12:"uint64",14:"matrix"},t={1:"cell",2:"struct",3:"object",4:"char",5:"sparse",6:"double",7:"single",8:"int8",9:"uint8",10:"int16",11:"uint16",12:"int32",13:"uint32",14:"int64",15:"uint64"};class r{constructor(e){this.buffer=e,this.pamat=[]}read(){for(;this.buffer.byteLength>0;)this.pamat.push(this.readDataElement())}readDataElement(){const t=this.readTag(),r=this.readData(t.type,t.length);return{type:e[t.type],value:r,length:t.length}}readTag(){const e=new DataView(this.buffer).getUint32(0,!0);let t,r;const a=e>>16&65535;return 0===a?(t=e&255,r=new DataView(this.buffer).getUint32(4,!0),this.buffer=this.buffer.slice(8)):(t=e&255,r=a,this.buffer=this.buffer.slice(4)),{type:t,length:r}}readData(e,r){let a;switch(e){case 1:a=this.readInt8(r);break;case 2:a=this.readUint8(r);break;case 3:a=this.readInt16(r);break;case 4:a=this.readUint16(r);break;case 5:a=this.readInt32(r);break;case 6:a=this.readUint32(r);break;case 7:a=this.readFloat32(r);break;case 9:a=this.readInt64(r);break;case 12:a=this.readUint64(r);break;case 14:a=new s(this.buffer.slice(0,r)).read();break;default:throw new Error(`Unsupported data type: ${e}`)}return this.buffer=this.buffer.slice(r),r%8!=0&&(this.buffer=this.buffer.slice(8-r%8)),a}readInt8(e){const t=new Int8Array(this.buffer.slice(0,e));return 1===t.length?t[0]:Array.from(t)}readUint8(e){const t=new Uint8Array(this.buffer.slice(0,e));return 1===t.length?t[0]:Array.from(t)}readInt16(e){const t=new Int16Array(this.buffer.slice(0,e));return 1===t.length?t[0]:Array.from(t)}readUint16(e){const t=new Uint16Array(this.buffer.slice(0,e));return 1===t.length?t[0]:Array.from(t)}readInt32(e){const t=new Int32Array(this.buffer.slice(0,e));return 1===t.length?t[0]:Array.from(t)}readUint32(e){const t=new Uint32Array(this.buffer.slice(0,e));return 1===t.length?t[0]:Array.from(t)}readFloat32(e){const t=new Float32Array(this.buffer.slice(0,e));return 1===t.length?t[0]:Array.from(t)}readInt64(e){const t=new BigInt64Array(this.buffer.slice(0,e));return 1===t.length?t[0]:Array.from(t)}readUint64(e){const t=new BigUint64Array(this.buffer.slice(0,e));return 1===t.length?t[0]:Array.from(t)}}class a{constructor(e,t,r){this.buffer=e,this.bytes=t,this.le=r,this.view=new DataView(this.buffer)}read(){let e;const t=this.view.getUint32(0,this.le),r=this.view.getUint32(4,this.le);if(0===r){const r=this.bytes-8;e=new Uint8Array(this.buffer,8,r)}else e=this.inflate(this.bytes-8);return e}inflate(e){const t=new Uint8Array(this.buffer,8,e);let r=0,a=0,i=new Uint8Array(this.bytes-8);for(;a<t.length;){const e=t[a],s=this.view.getUint16(a+1,this.le);if(a+=3,e<128){const h=new Uint8Array(this.buffer,a,s);i.set(h,r),r+=s,a+=s}else{const h=new Uint8Array(this.buffer,a,s);i.set(this.decompress(h),r),r+=e,a+=s}}return i}decompress(e){const t=new Uint8Array(e.length);let r=0;for(let a=0;a<e.length;a++){const i=e[a];if(i>=128){const s=this.view.getUint16(a+1,this.le),h=new Uint8Array(this.buffer,a+3,i);t.set(this.decompress(h),r),r+=s,a+=2+i}else t[r]=i,r++}return t}}class i{constructor(e,t){this.buffer=e,this.le=t,this.view=new DataView(this.buffer)}read(){const e=this.view.getUint32(0,this.le);return{version:e>>16,endian:6815792===e?">":"<",subsystem:65535&e}}}class s{constructor(e){this.buffer=e,this.pamat=[]}read(){for(;this.buffer.byteLength>0;)this.pamat.push(this.readDataElement())}readDataElement(){const e=this.readTag(),r=this.readData(e.type,e.length);return{type:e.type,value:r,length:e.length}}readTag(){const e=new DataView(this.buffer).getUint32(0,!0);let t,r;const a=e>>16&65535;return 0===a?(t=e&255,r=new DataView(this.buffer).getUint32(4,!0),this.buffer=this.buffer.slice(8)):(t=e&255,r=a,this.buffer=this.buffer.slice(4)),{type:t,length:r}}readData(e,r){let a;switch(e){case 1:a=this.readInt8(r);break;case 2:a=this.readUint8(r);break;case 3:a=this.readInt16(r);break;case 4:a=this.readUint16(r);break;case 5:a=this.readInt32(r);break;case 6:a=this.readUint32(r);break;case 7:a=this.readFloat32(r);break;case 9:a=this.readInt64(r);break;case 12:a=this.readUint64(r);break;case 14:a=this.readMatrix(r);break;case 15:a=this.readCompressed(r);break;default:this.buffer=this.buffer.slice(r)}return this.buffer=this.buffer.slice(r),r%8!=0&&(this.buffer=this.buffer.slice(8-r%8)),a}readInt8(e){const t=new Int8Array(this.buffer.slice(0,e));return 1===t.length?t[0]:t}readUint8(e){const t=new Uint8Array(this.buffer.slice(0,e));return 1===t.length?t[0]:t}readInt16(e){const t=new Int16Array(this.buffer.slice(0,e));return 1===t.length?t[0]:t}readUint16(e){const t=new Uint16Array(this.buffer.slice(0,e));return 1===t.length?t[0]:t}readInt32(e){const t=new Int32Array(this.buffer.slice(0,e));return 1===t.length?t[0]:t}readUint32(e){const t=new Uint32Array(this.buffer.slice(0,e));return 1===t.length?t[0]:t}readFloat32(e){const t=new Float32Array(this.buffer.slice(0,e));return 1===t.length?t[0]:t}readInt64(e){const t=new BigInt64Array(this.buffer.slice(0,e));return 1===t.length?t[0]:t}readUint64(e){const t=new BigUint64Array(this.buffer.slice(0,e));return 1===t.length?t[0]:t}readMatrix(e){return new s(this.buffer.slice(0,e)).read()}readCompressed(e){const t=new a(this.buffer.slice(0,e)).read();return new r(t).read()}}return class{constructor(){}static read(e){const r=new i(e.slice(124,128),!0).read();if("IM"!==new TextDecoder("utf-8").decode(e.slice(126,128)))throw new Error("Invalid endian indicator. Expected 'IM'.");const a=new DataView(e.buffer).getUint32(0,!0),s=new DataView(e.buffer).getUint32(4,!0);if(a>>16&65535,0===s)new DataView(e.buffer).getUint32(8,!0);e=e.slice(128);const h=new DataView(e.buffer).getUint32(0,!0),d=new DataView(e.buffer).getUint32(4,!0);if(14!==(65535&h))throw new Error("Invalid data type. Expected 'miMATRIX'.");const n=new DataView(e.buffer).getUint32(8,!0),l=new DataView(e.buffer).getUint32(12,!0);if(6!==(65535&n))throw new Error("Invalid array flags. Expected 'mxDOUBLE_CLASS'.");const u=new DataView(e.buffer).getUint32(16,!0),o=new DataView(e.buffer).getUint32(20,!0);if(5!==(65535&u))throw new Error("Invalid dimensions array. Expected 'miINT32'.");if(2!==o)throw new Error("Invalid dimensions. Expected 2.");const c=new DataView(e.buffer).getInt32(24,!0),f=new DataView(e.buffer).getInt32(28,!0),g=new DataView(e.buffer).getInt32(32,!0);if(1!==(65535&g))throw new Error("Invalid array name. Expected 'miINT8'.");const p=new DataView(e.buffer).getInt32(36,!0),w=new TextDecoder("utf-8").decode(e.slice(40,40+p));e=e.slice(40+p);p%8!=0&&(e=e.slice(8-p%8));const m=new DataView(e.buffer).getUint32(0,!0);if(l!==(65535&m))throw new Error("Invalid real part. Expected 'miDOUBLE'.");const b=new DataView(e.buffer).getUint32(4,!0);if(c*f*8!==b)throw new Error("Invalid real part length.");const v=new Float64Array(e.buffer.slice(8,8+b));let y=[];for(let e=0;e<f;e++){const t=[];for(let r=0;r<c;r++)t.push(v[e*c+r]);y.push(t)}const k={header:{description:new TextDecoder("utf-8").decode(e.slice(0,116)).replace(/\0/g,""),version:r.version,endianIndicator:r.endian},content:{pamat:[{type:t[l],value:y,name:w}]}};return k}}}));</script>
    <!-- Visualization & Export Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .leaflet-container { font-family: 'Inter', sans-serif; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3b82f6; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .info-box { background-color: #f3f4f6; border-left: 4px solid #6b7280; padding: 1rem; font-size: 0.9rem; color: #374151; }
        .info-box code { background-color: #e5e7eb; padding: 0.2rem 0.4rem; border-radius: 4px; font-family: monospace; }
        .dropzone { transition: background-color 0.2s, border-color 0.2s; }
        .dropzone.active { border-color: #3b82f6; background-color: #eff6ff; }
        .result-panel { min-height: 300px; }
    </style>
</head>
<body class="bg-gray-100 font-sans">

    <div id="app-container"></div>

    <script>
        // --- Translations ---
        const translations = {
            en: {
                title: "Krishi Kendra Pro",
                subtitle: "Your Advanced Field Analysis Partner",
                uploadTitle: "1. Upload Data Files",
                uploadCsv: "Drop .csv file or ",
                uploadMat: "Drop .mat file or ",
                browse: "click to browse",
                mappingTitle: "2. Specify Data Columns",
                processButton: "Fuse & Analyze Data",
                resultsTitle: "3. Fused Analysis Results",
                downloadPDF: "Download Report (PDF)",
                mergingStrategy: "Results are based on a pixel-by-pixel average of Red/NIR bands from all valid sources. Soil moisture uses an average if present in both, otherwise data from the single available source is used.",
                dimensionWarning: "This requires both files to have identical matrix dimensions.",
                resetButton: "Analyze New Files",
                redIndex: "Red Index",
                nirIndex: "NIR Index",
                moistureIndex: "Moisture Index",
                optional: "(opt)",
                csvSettings: "CSV File Settings",
                matSettings: "MAT File Settings",
                ndviHeatmap: "NDVI Heatmap",
                moistureMap: "Soil Moisture Map",
                summaryTitle: "Field Analysis Report",
                avgNdvi: "Average NDVI",
                avgMoisture: "Average Soil Moisture",
                avgSoilTemp: "Average Soil Temp.",
                stressAlert: "Crop Stress Alert",
                spectralSignature: "Average Spectral Signature",
                spectralDescription: "Reflectance across different wavelengths.",
                healthDistribution: "Crop Health Distribution",
                healthDistributionDescription: "Percentage of the field in different health categories.",
                recommendationsTitle: "Key Takeaways & Recommendations",
                downloadXls: "Export as XLSX",
                downloadMat: "Export as .MAT"
            },
            hi: {
                title: "कृषि केंद्र प्रो",
                subtitle: "आपका उन्नत क्षेत्र विश्लेषण भागीदार",
                uploadTitle: "१. डेटा फ़ाइलें अपलोड करें",
                uploadCsv: ".csv फ़ाइल ड्रॉप करें या ",
                uploadMat: ".mat फ़ाइल ड्रॉप करें या ",
                browse: "ब्राउज़ करने के लिए क्लिक करें",
                mappingTitle: "२. डेटा कॉलम निर्दिष्ट करें",
                processButton: "डेटा मिलाएं और विश्लेषण करें",
                resultsTitle: "३. संयुक्त विश्लेषण परिणाम",
                downloadPDF: "रिपोर्ट डाउनलोड करें (PDF)",
                mergingStrategy: "परिणाम सभी स्रोतों से Red/NIR बैंड के पिक्सेल-दर-पिक्सेल औसत पर आधारित हैं। मिट्टी की नमी दोनों में मौजूद होने पर औसत का उपयोग करती है, अन्यथा एकल स्रोत से डेटा का उपयोग किया जाता है।",
                dimensionWarning: "इसके लिए दोनों फाइलों में समान मैट्रिक्स आयाम होना आवश्यक है।",
                resetButton: "नई फाइलों का विश्लेषण करें",
                redIndex: "लाल बैंड इंडेक्स",
                nirIndex: "एनआईआर बैंड इंडेक्स",
                moistureIndex: "नमी इंडेक्स",
                optional: "(वैकल्पिक)",
                csvSettings: "CSV फ़ाइल सेटिंग्स",
                matSettings: "MAT फ़ाइल सेटिंग्स",
                ndviHeatmap: "NDVI हीटमैप",
                moistureMap: "मिट्टी नमी का नक्शा",
                summaryTitle: "क्षेत्र विश्लेषण रिपोर्ट",
                avgNdvi: "औसत NDVI",
                avgMoisture: "औसत मिट्टी की नमी",
                avgSoilTemp: "औसत मिट्टी का तापमान",
                stressAlert: "फसल तनाव चेतावनी",
                spectralSignature: "औसत स्पेक्ट्रल हस्ताक्षर",
                spectralDescription: "विभिन्न तरंग दैर्ध्य पर परावर्तन।",
                healthDistribution: "फसल स्वास्थ्य वितरण",
                healthDistributionDescription: "विभिन्न स्वास्थ्य श्रेणियों में खेत का प्रतिशत।",
                recommendationsTitle: "मुख्य सुझाव और सिफारिशें",
                downloadXls: "XLSX के रूप में निर्यात करें",
                downloadMat: ".MAT के रूप में निर्यात करें"
            }
        };

        // --- State Management ---
        let csvFile = null;
        let matFile = null;
        let currentLang = 'en';
        let jobDetails = {};
        let currentReportData = {};
        
        const appContainer = document.getElementById('app-container');

        // --- Main Render Function ---
        function renderApp() {
            const t = translations[currentLang];
            appContainer.innerHTML = `
                <header class="bg-white shadow-md p-4 flex justify-between items-center">
                    <div class="flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 text-green-600" viewBox="0 0 20 20" fill="currentColor"><path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z" /></svg>
                        <h1 class="text-2xl font-bold text-gray-800 ml-2">${t.title}</h1>
                    </div>
                    <div class="flex items-center">
                        <span class="text-sm font-medium text-gray-600 mr-2">Language:</span>
                        <button id="lang-en" class="px-3 py-1 text-sm rounded-md ${currentLang === 'en' ? 'bg-green-600 text-white' : 'bg-gray-200'}">EN</button>
                        <button id="lang-hi" class="px-3 py-1 text-sm rounded-md ml-2 ${currentLang === 'hi' ? 'bg-green-600 text-white' : 'bg-gray-200'}">HI</button>
                    </div>
                </header>
                <main id="main-content" class="bg-white rounded-xl shadow-lg p-6 md:p-8 max-w-7xl mx-auto mt-8"></main>
            `;
            document.getElementById('lang-en').addEventListener('click', () => { currentLang = 'en'; resetUI(); });
            document.getElementById('lang-hi').addEventListener('click', () => { currentLang = 'hi'; resetUI(); });
            resetUI(); // Initialize the UI
        }

        // --- UI Rendering Functions ---
        function renderUploadUI() {
            const t = translations[currentLang];
            const main = document.getElementById('main-content');
            main.innerHTML = `
                <div id="upload-section">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                        <div><label class="block text-sm font-medium text-gray-700">Field Name</label><input id="field-name" type="text" value="Farm-A, Punjab" class="mt-1 block w-full p-2 border rounded-md"/></div>
                        <div><label class="block text-sm font-medium text-gray-700">Analysis Date</label><input id="analysis-date" type="date" value="${new Date().toISOString().split('T')[0]}" class="mt-1 block w-full p-2 border rounded-md"/></div>
                        <div><label class="block text-sm font-medium text-gray-700">Sensor Type</label><select id="sensor-type" class="mt-1 block w-full p-2 border rounded-md"><option>Multispectral Drone</option><option>Hyperspectral Satellite</option></select></div>
                    </div>
                    <h2 class="text-2xl font-semibold mb-4">${t.uploadTitle}</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div id="dropzone-csv" class="dropzone border-2 border-dashed rounded-lg p-8 text-center cursor-pointer">
                            <input type="file" id="file-input-csv" class="hidden" accept=".csv" /><svg class="mx-auto h-10 w-10 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                            <p class="mt-2 text-sm text-gray-600">${t.uploadCsv}<span class="font-semibold text-blue-600">${t.browse}</span></p>
                            <p id="file-name-csv" class="mt-2 text-sm font-semibold text-green-700"></p>
                        </div>
                        <div id="dropzone-mat" class="dropzone border-2 border-dashed rounded-lg p-8 text-center cursor-pointer">
                            <input type="file" id="file-input-mat" class="hidden" accept=".mat" /><svg class="mx-auto h-10 w-10 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4M4 7v10m16-10v10"></path></svg>
                            <p class="mt-2 text-sm text-gray-600">${t.uploadMat}<span class="font-semibold text-blue-600">${t.browse}</span></p>
                            <p id="file-name-mat" class="mt-2 text-sm font-semibold text-green-700"></p>
                        </div>
                    </div>
                </div>
                <div id="columns-section" class="hidden mt-6 border-t pt-6">
                    <h2 class="text-2xl font-semibold mb-4">${t.mappingTitle}</h2>
                    <div id="csv-mapping-section" class="hidden bg-gray-50 p-4 rounded-lg mb-4"></div>
                    <div id="mat-mapping-section" class="hidden bg-gray-50 p-4 rounded-lg"></div>
                    <button id="process-button" class="w-full mt-6 bg-blue-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-blue-700 transition" disabled>${t.processButton}</button>
                </div>
                <div id="results-section" class="hidden border-t pt-6 mt-6"></div>
            `;
        }
        
        // --- ADAPTED CODE ---
        let dom = {};

        function initializeDOM() {
            dom = {
                main: document.getElementById('main-content'),
                uploadSection: document.getElementById('upload-section'),
                columnsSection: document.getElementById('columns-section'),
                resultsSection: document.getElementById('results-section'),
                processButton: document.getElementById('process-button'),
                csv: {
                    dropzone: document.getElementById('dropzone-csv'),
                    fileInput: document.getElementById('file-input-csv'),
                    fileName: document.getElementById('file-name-csv'),
                    mapping: document.getElementById('csv-mapping-section'),
                },
                mat: {
                    dropzone: document.getElementById('dropzone-mat'),
                    fileInput: document.getElementById('file-input-mat'),
                    fileName: document.getElementById('file-name-mat'),
                    mapping: document.getElementById('mat-mapping-section'),
                }
            };
            const setupDropzone = (type) => {
                const dropzone = dom[type].dropzone;
                const fileInput = dom[type].fileInput;
                if (!dropzone || !fileInput) return;

                dropzone.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (e) => handleFileSelect(e.target.files[0], type));

                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    dropzone.addEventListener(eventName, (e) => { e.preventDefault(); e.stopPropagation(); }, false);
                });
                ['dragenter', 'dragover'].forEach(eventName => {
                    dropzone.addEventListener(eventName, () => dropzone.classList.add('active'), false);
                });
                ['dragleave', 'drop'].forEach(eventName => {
                    dropzone.addEventListener(eventName, () => dropzone.classList.remove('active'), false);
                });
                dropzone.addEventListener('drop', (e) => { handleFileSelect(e.dataTransfer.files[0], type); }, false);
            };
            setupDropzone('csv');
            setupDropzone('mat');
            dom.processButton.addEventListener('click', analyzeFiles);
        }

        function handleFileSelect(file, type) {
            if (!file) return;
            const valid = type === 'csv' ? file.name.endsWith('.csv') : file.name.endsWith('.mat');
            if (valid) {
                if (type === 'csv') csvFile = file;
                if (type === 'mat') matFile = file;
                dom[type].fileName.textContent = `Selected: ${file.name}`;
                renderMappingUI(type);
                dom.columnsSection.classList.remove('hidden');
                dom.processButton.disabled = false;
            } else {
                alert(`Please select a valid .${type} file.`);
            }
        }
        
        function renderMappingUI(type) {
            const t = translations[currentLang];
            const container = dom[type].mapping;
            container.innerHTML = `
                <h3 class="font-bold mb-2">${type === 'csv' ? t.csvSettings : t.matSettings}</h3>
                <div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
                    <div><label for="red-col-${type}" class="block text-sm font-medium">${t.redIndex}</label><input type="number" id="red-col-${type}" value="2" class="mt-1 block w-full p-2 border border-gray-300 rounded-md"></div>
                    <div><label for="nir-col-${type}" class="block text-sm font-medium">${t.nirIndex}</label><input type="number" id="nir-col-${type}" value="3" class="mt-1 block w-full p-2 border border-gray-300 rounded-md"></div>
                    <div><label for="moisture-col-${type}" class="block text-sm font-medium">${t.moistureIndex} <span class="text-xs">${t.optional}</span></label><input type="number" id="moisture-col-${type}" placeholder="e.g., 4" class="mt-1 block w-full p-2 border border-gray-300 rounded-md"></div>
                </div>
            `;
            container.classList.remove('hidden');
        }

        async function analyzeFiles() {
            if (dom.uploadSection) dom.uploadSection.style.display = 'none';
            if (dom.columnsSection) dom.columnsSection.style.display = 'none';
            const resultsSection = document.getElementById('results-section');
            resultsSection.classList.remove('hidden');
            resultsSection.innerHTML = `<div class="text-center" id="status-section"><div class="loader mx-auto"></div><p class="mt-4 font-semibold">Processing files...</p></div>`;

            jobDetails = {
                fieldName: document.getElementById('field-name').value,
                analysisDate: document.getElementById('analysis-date').value,
                sensorType: document.getElementById('sensor-type').value,
            };

            let csvData = null, matData = null;
            let csvError = null, matError = null;

            if (csvFile) { try { csvData = await parseFile('csv'); } catch (e) { csvError = e.message; } }
            if (matFile) { try { matData = await parseFile('mat'); } catch (e) { matError = e.message; } }
            
            const statusSection = document.getElementById('status-section');
            statusSection.innerHTML = ''; // Clear loader
            if(csvError) statusSection.innerHTML += renderStatus('error', `CSV Error: ${csvError}`);
            if(matError) statusSection.innerHTML += renderStatus('error', `MAT Error: ${matError}`);

            let mergedMatrix, mergedMoisture, allPixels;

            if (csvData && matData) {
                try {
                    if (csvData.length !== matData.length) throw new Error(`Pixel counts do not match (CSV: ${csvData.length}, MAT: ${matData.length}).`);
                    statusSection.innerHTML += renderStatus('info', 'Both files valid. Merging datasets...');
                    ({ mergedMatrix, mergedMoisture, allPixels } = mergeData(csvData, matData));
                } catch(e) {
                    statusSection.innerHTML += renderStatus('error', `Merge Error: ${e.message}.`);
                    return;
                }
            } else if (csvData) {
                 statusSection.innerHTML += renderStatus('info', 'Processing CSV file only.');
                 mergedMatrix = csvData.map(p => [p.red, p.nir]);
                 mergedMoisture = csvData.map(p => p.moisture);
                 allPixels = csvData;
            } else if (matData) {
                statusSection.innerHTML += renderStatus('info', 'Processing MAT file only.');
                mergedMatrix = matData.map(p => [p.red, p.nir]);
                mergedMoisture = matData.map(p => p.moisture);
                allPixels = matData;
            } else {
                statusSection.innerHTML += renderStatus('error', 'No valid data to process.');
                return;
            }
            
            const { ndviData, moistureData } = processMergedMatrix(mergedMatrix, mergedMoisture);
            
            // Store results globally for download functions
            currentReportData = {
                ndvi: ndviData,
                moisture: moistureData,
                allPixels: allPixels
            };

            renderResultsUI(ndviData, moistureData, allPixels);
        }

        async function parseFile(type) {
            const redCol = parseInt(document.getElementById(`red-col-${type}`).value);
            const nirCol = parseInt(document.getElementById(`nir-col-${type}`).value);
            const moistureColRaw = document.getElementById(`moisture-col-${type}`).value;
            const moistureCol = moistureColRaw !== '' ? parseInt(moistureColRaw) : null;
            if(isNaN(redCol) || isNaN(nirCol)) throw new Error("Red/NIR indices required.");
            
            const fileContent = await readFile(type === 'csv' ? csvFile : matFile);
            const pixelMatrix = type === 'csv' ? parseCSV(fileContent) : parseMAT(fileContent);
            if (!pixelMatrix || pixelMatrix.length === 0) throw new Error("Could not parse matrix.");

            return pixelMatrix.map(pixel => {
                if(pixel.length <= Math.max(redCol, nirCol)) return null;
                const red = pixel[redCol];
                const nir = pixel[nirCol];
                const moisture = (moistureCol !== null && pixel.length > moistureCol) ? pixel[moistureCol] : NaN;
                if(isNaN(red) || isNaN(nir)) return null;
                return { red, nir, moisture, allBands: pixel };
            }).filter(p => p !== null);
        }
        
        function mergeData(csvData, matData) {
            const mergedMatrix = [];
            const mergedMoisture = [];
            const allPixels = [];
            for(let i = 0; i < csvData.length; i++) {
                const csvPixel = csvData[i];
                const matPixel = matData[i];
                
                mergedMatrix.push([
                    (csvPixel.red + matPixel.red) / 2,
                    (csvPixel.nir + matPixel.nir) / 2
                ]);

                const csvM = csvPixel.moisture;
                const matM = matPixel.moisture;
                if(!isNaN(csvM) && !isNaN(matM)) mergedMoisture.push((csvM + matM) / 2);
                else if(!isNaN(csvM)) mergedMoisture.push(csvM);
                else if(!isNaN(matM)) mergedMoisture.push(matM);
                else mergedMoisture.push(NaN);
                
                allPixels.push({red: (csvPixel.red + matPixel.red) / 2, nir: (csvPixel.nir + matPixel.nir) / 2, moisture: mergedMoisture[i], allBands: csvPixel.allBands});
            }
            return { mergedMatrix, mergedMoisture, allPixels };
        }
        
        function processMergedMatrix(mergedMatrix, mergedMoisture) {
            const ndviData = mergedMatrix.map(([red, nir]) => {
                let ndvi = (nir + red) === 0 ? 0 : (nir - red) / (nir + red);
                return Math.max(-1, Math.min(1, ndvi));
            });
            const side = Math.ceil(Math.sqrt(ndviData.length));
            return {
                ndviData: to2D(ndviData, side),
                moistureData: to2D(mergedMoisture, side)
            };
        }
        
        function renderResultsUI(ndviData, moistureData, allPixels){
            const t = translations[currentLang];
            const flatNdvi = ndviData.flat().filter(v=>!isNaN(v));
            const flatMoisture = moistureData.flat().filter(v=>!isNaN(v));
            const stats = {
                avgNdvi: flatNdvi.length > 0 ? getStats(flatNdvi).mean : 0,
                avgMoisture: flatMoisture.length > 0 ? getStats(flatMoisture).mean : 0,
                avgSoilTemp: 24.5, // Mock data
            };
            stats.stressAlert = stats.avgNdvi < 0.65 ? "High" : (stats.avgNdvi < 0.75 ? "Moderate" : "Low");
            
            // Store stats for downloads
            currentReportData.stats = stats;

            const resultsSection = document.getElementById('results-section');
            const statusHTML = resultsSection.querySelector('#status-section') ? resultsSection.querySelector('#status-section').innerHTML : '';

            resultsSection.innerHTML = `
                ${statusHTML}
                <div id="final-results">
                    <h2 class="text-3xl font-bold text-center mb-6">${t.summaryTitle}</h2>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                        <div class="bg-white p-6 rounded-xl shadow-lg border-l-4 border-green-500"><h3 class="text-sm font-semibold text-gray-500">${t.avgNdvi}</h3><p class="text-3xl font-bold text-green-800">${stats.avgNdvi.toFixed(2)}</p></div>
                        <div class="bg-white p-6 rounded-xl shadow-lg border-l-4 border-blue-500"><h3 class="text-sm font-semibold text-gray-500">${t.avgMoisture}</h3><p class="text-3xl font-bold text-blue-800">${stats.avgMoisture.toFixed(1)}%</p></div>
                        <div class="bg-white p-6 rounded-xl shadow-lg border-l-4 border-yellow-500"><h3 class="text-sm font-semibold text-gray-500">${t.avgSoilTemp}</h3><p class="text-3xl font-bold text-yellow-800">${stats.avgSoilTemp.toFixed(1)}°C</p></div>
                        <div class="bg-white p-6 rounded-xl shadow-lg border-l-4 border-red-500"><h3 class="text-sm font-semibold text-gray-500">${t.stressAlert}</h3><p class="text-3xl font-bold text-red-800">${stats.stressAlert}</p></div>
                    </div>

                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                        <div id="ndvi-panel" class="result-panel bg-white p-6 rounded-xl shadow-lg"></div>
                        <div id="moisture-panel" class="result-panel bg-white p-6 rounded-xl shadow-lg"></div>
                    </div>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                        <div class="bg-white p-6 rounded-xl shadow-lg"><h3 class="text-xl font-bold">${t.spectralSignature}</h3><p class="text-sm text-gray-500 mb-4">${t.spectralDescription}</p><canvas id="spectral-chart"></canvas></div>
                        <div class="bg-white p-6 rounded-xl shadow-lg"><h3 class="text-xl font-bold">${t.healthDistribution}</h3><p class="text-sm text-gray-500 mb-4">${t.healthDistributionDescription}</p><canvas id="health-chart"></canvas></div>
                    </div>
                     <div class="bg-white p-6 rounded-xl shadow-lg mb-8">
                        <h3 class="text-xl font-bold">${t.recommendationsTitle}</h3>
                        <ul id="recommendations-list" class="mt-4 list-disc list-inside text-gray-700 space-y-2"></ul>
                     </div>
                    <div class="bg-white rounded-xl shadow-lg p-6 text-center grid grid-cols-2 md:grid-cols-4 gap-4">
                         <button id="download-pdf" class="w-full bg-red-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-red-700">Download PDF</button>
                         <button id="download-xls" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-green-700">${t.downloadXls}</button>
                         <button id="download-mat" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-green-700">${t.downloadMat}</button>
                         <button id="reset-button" class="w-full bg-gray-600 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-gray-700">${t.resetButton}</button>
                    </div>
                </div>
            `;
            
            renderResultPanel(document.getElementById('ndvi-panel'), t.ndviHeatmap, ndviData, true, 'combined_ndvi');
            renderResultPanel(document.getElementById('moisture-panel'), t.moistureMap, moistureData, false, 'combined_moisture');
            
            renderExtraVisuals(allPixels, stats, t);

            // Attach listeners for download buttons
            document.getElementById('reset-button').addEventListener('click', resetUI);
            document.getElementById('download-pdf').addEventListener('click', downloadPDF);
            document.getElementById('download-xls').addEventListener('click', downloadXLSX);
            document.getElementById('download-mat').addEventListener('click', downloadMAT);
        }

        function renderExtraVisuals(allPixels, stats, t) {
            const avgSpectrum = getAverageSpectrum(allPixels);
            new Chart(document.getElementById('spectral-chart'), {
                type: 'line', data: { labels: avgSpectrum.map((_,i)=>`Band ${i}`), datasets: [{ label: 'Reflectance', data: avgSpectrum, borderColor: 'rgb(75, 192, 192)', tension: 0.1 }] }
            });
            new Chart(document.getElementById('health-chart'), {
                type: 'bar', data: { labels: ['Healthy', 'Moderate', 'Stressed'], datasets: [{ label: '% of Field', data: [stats.avgNdvi*100, (1-stats.avgNdvi)*40, (1-stats.avgNdvi)*60], backgroundColor: ['#22c55e', '#facc15', '#ef4444'] }] }, options: { indexAxis: 'y' }
            });
            const recList = document.getElementById('recommendations-list');
            const recs = [`Overall crop health (NDVI: ${stats.avgNdvi.toFixed(2)}) is currently in a ${stats.stressAlert.toLowerCase()} state.`];
            if(stats.avgMoisture < 40) recs.push("ACTION: Soil moisture is low. Consider irrigation.");
            recList.innerHTML = recs.map(r => `<li>${r}</li>`).join('');
        }

        function getAverageSpectrum(pixels) {
            if(!pixels || pixels.length === 0) return [];
            const numBands = pixels[0].allBands.length;
            const sums = Array(numBands).fill(0);
            pixels.forEach(p => {
                for(let i=0; i<numBands; i++) {
                    if(!isNaN(p.allBands[i])) sums[i] += p.allBands[i];
                }
            });
            return sums.map(s => s / pixels.length);
        }
        
        function resetUI() {
            csvFile = null;
            matFile = null;
            currentReportData = {};
            renderUploadUI();
            initializeDOM();
        }

        function renderStatus(type, message) {
            const color = type === 'error' ? 'red' : 'blue';
            return `<div class="p-3 my-2 bg-${color}-100 text-${color}-800 border border-${color}-300 rounded-lg">${message}</div>`;
        }

         function renderResultPanel(panel, title, data, isNdvi, downloadName) {
            if(!data || data.flat().every(v => isNaN(v))) {
                panel.innerHTML = `<h3 class="text-xl font-semibold mb-2">${title}</h3><div class="flex justify-center items-center h-48 text-gray-500 bg-gray-50 rounded-lg">No valid data to display.</div>`;
                return;
            }

            const canvasId = `${panel.id}-canvas`;
            panel.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <h3 class="text-xl font-semibold">${title}</h3>
                    <p id="${panel.id}-hover" class="text-sm font-mono bg-gray-100 px-2 py-1 rounded">-</p>
                </div>
                <canvas id="${canvasId}" class="w-full rounded-lg border shadow-md cursor-crosshair"></canvas>
                <div class="flex items-center justify-between mt-2">
                    <span id="${panel.id}-min" class="text-xs"></span>
                    <div id="${panel.id}-legend" class="h-4 w-full mx-2 rounded-full"></div>
                    <span id="${panel.id}-max" class="text-xs"></span>
                </div>
                <div id="${panel.id}-stats" class="mt-2 text-sm text-center font-mono bg-gray-50 p-2 rounded-lg"></div>
                <button id="download-${downloadName}" class="w-full mt-2 text-sm bg-gray-200 py-2 rounded-md hover:bg-gray-300 transition">Download Matrix CSV</button>
            `;
            drawHeatmap(canvasId, data, isNdvi ? getNdviColor : getMoistureColor, isNdvi, `${panel.id}-hover`, `${panel.id}-stats`, `${panel.id}-legend`, `${panel.id}-min`, `${panel.id}-max`);
            document.getElementById(`download-${downloadName}`).addEventListener('click', () => downloadCSV(`${downloadName}.csv`, data));
        }

        function drawHeatmap(canvasId, data, getColor, isNdvi, hoverId, statsId, legendId, minId, maxId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            const flatData = data.flat().filter(v => !isNaN(v));
            if (flatData.length === 0) return;
            const stats = getStats(flatData);
            const min = isNdvi ? -1 : stats.min;
            const max = isNdvi ? 1 : stats.max;
            const rows = data.length, cols = data[0].length;
            canvas.width = cols; canvas.height = rows;
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const value = data[y][x];
                    if (isNaN(value)) { ctx.fillStyle = '#f0f0f0'; }
                    else { ctx.fillStyle = getColor((value - min) / (max - min)); }
                    ctx.fillRect(x, y, 1, 1);
                }
            }
            document.getElementById(statsId).innerHTML = `Min: ${stats.min.toFixed(3)} | Max: ${stats.max.toFixed(3)} | Mean: ${stats.mean.toFixed(3)}`;
            document.getElementById(legendId).style.background = `linear-gradient(to right, ${Array.from({length:100},(_,i)=>getColor(i/99)).join(',')})`;
            document.getElementById(minId).textContent = min.toFixed(1);
            document.getElementById(maxId).textContent = max.toFixed(1);
            const hoverEl = document.getElementById(hoverId);
            canvas.onmousemove = e => {
                const rect = canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / rect.width * cols);
                const y = Math.floor((e.clientY - rect.top) / rect.height * rows);
                const val = data[y]?.[x];
                hoverEl.textContent = !isNaN(val) ? val.toFixed(4) : '-';
            };
            canvas.onmouseleave = () => hoverEl.textContent = '-';
        }
        
        // **FIX STARTS HERE: RESTORING/ADDING HELPER FUNCTIONS**
        const readFile = (file) => new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = e => resolve(e.target.result);
            reader.onerror = () => reject(new Error("Failed to read file."));
            if (file.name.endsWith('.mat')) reader.readAsArrayBuffer(file);
            else reader.readAsText(file);
        });

        async function downloadPDF() {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('p', 'mm', 'a4');
            const content = document.getElementById('final-results');
            if(!content) return;
            const canvas = await html2canvas(content, { scale: 2 });
            const imgData = canvas.toDataURL('image/png');
            const imgProps = pdf.getImageProperties(imgData);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
            pdf.addImage(imgData, 'PNG', 0, 0, pdfWidth, pdfHeight);
            pdf.save(`Krishi_Report_${jobDetails.fieldName}.pdf`);
        }
        
        function downloadXLSX() {
            const t = translations[currentLang];
            const stats = currentReportData.stats;
            const summaryData = [
                { Metric: "Field Name", Value: jobDetails.fieldName },
                { Metric: "Date", Value: jobDetails.analysisDate },
                { Metric: t.avgNdvi, Value: stats.avgNdvi },
                { Metric: t.avgMoisture, Value: stats.avgMoisture },
                { Metric: t.stressAlert, Value: stats.stressAlert },
            ];

            const wb = XLSX.utils.book_new();
            const summarySheet = XLSX.utils.json_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, summarySheet, "Summary");
            
            if (currentReportData.ndvi) {
                const ndviSheet = XLSX.utils.aoa_to_sheet(currentReportData.ndvi);
                XLSX.utils.book_append_sheet(wb, ndviSheet, "NDVI Data");
            }
             if (currentReportData.moisture) {
                const moistureSheet = XLSX.utils.aoa_to_sheet(currentReportData.moisture);
                XLSX.utils.book_append_sheet(wb, moistureSheet, "Moisture Data");
            }
            
            XLSX.writeFile(wb, `Report_${jobDetails.fieldName}.xlsx`);
        }

        function downloadMAT() {
            const dataToSave = {
                report: {
                    jobDetails: jobDetails,
                    stats: currentReportData.stats,
                    ndvi: currentReportData.ndvi,
                    moisture: currentReportData.moisture
                }
            };
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(dataToSave, null, 2));
            const link = document.createElement("a");
            link.setAttribute("href", dataStr);
            link.setAttribute("download", `Report_${jobDetails.fieldName}.mat`);
            link.click();
        }

        const getStats = arr => ({ min: Math.min(...arr), max: Math.max(...arr), mean: arr.reduce((a, b) => a + b, 0) / arr.length });
        const to2D = (arr, width) => Array.from({ length: Math.ceil(arr.length / width) }, (_, i) => arr.slice(i * width, i * width + width));
        const getMoistureColor = norm => `hsl(${240 - norm * 120}, 80%, 50%)`;
        const getNdviColor = norm => `hsl(${norm * 120}, 90%, 45%)`;
        const downloadCSV = (filename, matrix) => {
            const csv = matrix.map(e => e.join(",")).join("\n");
            const link = document.createElement("a");
            link.href = "data:text/csv;charset=utf-8," + encodeURI(csv);
            link.download = filename;
            link.click();
        };
         const parseCSV = (csvText) => {
            const rows = csvText.trim().split('\n');
            const isHeader = isNaN(parseFloat(rows[0].split(',')[0]));
            return (isHeader ? rows.slice(1) : rows).map(r => r.split(',').map(parseFloat));
        };
        const parseMAT = (buffer) => {
            if (typeof matFileParser === 'undefined') { throw new Error("MAT parser library could not be loaded."); }
            const data = matFileParser.read(new Uint8Array(buffer));
            if (!data?.content?.pamat) throw new Error("Invalid .mat structure.");
            const arrays = data.content.pamat.filter(item => item && Array.isArray(item.value) && typeof item.value[0] !== 'string');
            if (arrays.length === 0) throw new Error("No numerical matrix found.");
            arrays.sort((a, b) => (b.value.length * (b.value[0]?.length || 1)) - (a.value.length * (a.value[0]?.length || 1)));
            let matrix = arrays[0].value;
            return Array.isArray(matrix[0]?.[0]) ? matrix.flat() : matrix;
        };
        // **FIX ENDS HERE**

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', renderApp);
    </script>
</body>
</html>
